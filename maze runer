{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "ename": "",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31mJupyter cannot be started. Error attempting to locate jupyter: Running cells with 'Python 2.7.18 64-bit' requires jupyter and notebook package.\n",
      "Run the following command to install 'jupyter and notebook' into the Python environment. \n",
      "Command: '/System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python -m pip install jupyter notebook -U'"
     ]
    }
   ],
   "source": [
    "import pygame, random\n",
    "from pygame.mixer import *\n",
    "\n",
    "############################################################\n",
    "#    常數宣告\n",
    "############################################################\n",
    "\n",
    "FPS = 30\n",
    "L = 30\n",
    "WALL = 1\n",
    "ROUTE = 0\n",
    "Wallx, Wally = 16, 16\n",
    "WIDTH = L * Wallx + 40\n",
    "HEIGHT = L * Wally + 60\n",
    "\n",
    "WHITE = (255,255,255)\n",
    "BLACK = (0,0,0)\n",
    "GRAY = (80, 80, 80)\n",
    "RED = (255,0,0)\n",
    "GREEN = (0,255,0)\n",
    "BLUE = (0,0,255)\n",
    "DARKBLUE = (16, 24, 56)\n",
    "DARKRED = (56, 16, 16)\n",
    "\n",
    "\n",
    "\n",
    "############################################################\n",
    "#    元件建構\n",
    "############################################################\n",
    "\n",
    "def Maze_init(screen, DoorImg, randomExit = False):\n",
    "    Maze = [[0 for i in range(L)] for j in range(L)]\n",
    "    #外側一圈為牆    \n",
    "    for i in range(L):\n",
    "        Maze[0][i] = WALL\n",
    "        Maze[i][0] = WALL\n",
    "        Maze[L-1][i] = WALL\n",
    "        Maze[i][L-1] = WALL\n",
    "\n",
    "    #生成迷宮\n",
    "    CreateMaze(Maze, 1, 1, L-2, L-2)\n",
    "\n",
    "    #設定入口、出口\n",
    "    if randomExit:\n",
    "        Maze[1][0] = ROUTE\n",
    "        exit_correct = False\n",
    "        exit_dir = random.randrange(0, 2) # 0 = 右邊， 1 = 下方\n",
    "        x = y = 0\n",
    "        while not exit_correct:\n",
    "            exit_pos = random.randrange(1, L-2)\n",
    "            if exit_dir:#True 出口在右而不是下\n",
    "                if Maze[exit_pos][L-2] == ROUTE:#判斷出口前要沒有牆\n",
    "                    Maze[exit_pos][L-1] = ROUTE\n",
    "                    x = L-1\n",
    "                    y = exit_pos\n",
    "                    exit_correct = True           \n",
    "            else:\n",
    "                if Maze[L-2][exit_pos] == ROUTE:#判斷出口前要沒有牆\n",
    "                    Maze[L-1][exit_pos] = ROUTE\n",
    "                    x = exit_pos\n",
    "                    y = L-1\n",
    "                    exit_correct = True\n",
    "        DoorRect = screen.blit(DoorImg, (20 + x*Wallx, 40 + y*Wally))\n",
    "        return Maze, DoorRect\n",
    "    else:\n",
    "        Maze[1][0] = ROUTE\n",
    "        Maze[L-2][L-1] = ROUTE\n",
    "        DoorRect = screen.blit(DoorImg, (20 + (L-1)*Wallx, 40 + (L-2)*Wally))\n",
    "        return Maze, DoorRect\n",
    "    \n",
    "    ''' \n",
    "    #印出陣列迷宮\n",
    "    for i in range(L):\n",
    "        for j in range(L):\n",
    "            if Maze[i][j]==0:\n",
    "                print(\"  \",end='');\n",
    "            else:\n",
    "                print(\"11\",end='')\n",
    "        print()\n",
    "    '''\n",
    "\n",
    "def CreateMaze(maze, x1, y1, x2, y2):\n",
    "    #判斷是否還能繼續分割\n",
    "    if not (x2-x1 < 2 or y2-y1 < 2):\n",
    "            \n",
    "        #隨機取點\n",
    "        x = x1 + 1 + random.randrange(x2-x1-1)\n",
    "        y = y1 + 1 + random.randrange(y2-y1-1)\n",
    "\n",
    "        #畫牆\n",
    "        for i in range(x1, x2+1):\n",
    "            maze[i][y] = WALL\n",
    "        for i in range(y1, y2+1):\n",
    "            maze[x][i] = WALL\n",
    "\n",
    "        #遞迴分割，繼續劃分區域\n",
    "        CreateMaze(maze, x1, y1, x-1, y-1)\n",
    "        CreateMaze(maze, x+1, y+1, x2, y2)\n",
    "        CreateMaze(maze, x+1, y1, x2, y-1)\n",
    "        CreateMaze(maze, x1, y+1, x-1, y2)\n",
    "\n",
    "        #隨機取其中的三面牆\n",
    "        r = [0 for i in range(4)]\n",
    "        r[random.randrange(0,4)] = 1\n",
    "        \n",
    "        #在牆上隨機取點開孔\n",
    "        for i in range(4):\n",
    "            if r[i] == 0:\n",
    "                rx = x\n",
    "                ry = y\n",
    "                if i == 0:\n",
    "                    rx = x1 + random.randrange(x-x1)\n",
    "                    while (maze[rx-1][ry] + maze[rx+1][ry] + maze[rx][ry-1] + maze[rx][ry+1] > 2*WALL):\n",
    "                        rx = x1 + random.randrange(x-x1)\n",
    "                elif i == 1:\n",
    "                    ry = y + 1 + random.randrange(y2-y)\n",
    "                    while (maze[rx-1][ry] + maze[rx+1][ry] + maze[rx][ry-1] + maze[rx][ry+1] > 2*WALL):\n",
    "                        ry = y + 1 + random.randrange(y2-y)\n",
    "                elif i == 2:\n",
    "                    rx = x + 1 + random.randrange(x2-x)\n",
    "                    while (maze[rx-1][ry] + maze[rx+1][ry] + maze[rx][ry-1] + maze[rx][ry+1] > 2*WALL):\n",
    "                        rx = x + 1 + random.randrange(x2-x)\n",
    "                elif i == 3:\n",
    "                    ry = y1 + random.randrange(y-y1)\n",
    "                    while (maze[rx-1][ry] + maze[rx+1][ry] + maze[rx][ry-1] + maze[rx][ry+1]>2*WALL):\n",
    "                        ry = y1 + random.randrange(y-y1)\n",
    "                maze[rx][ry] = ROUTE\n",
    "                \n",
    "def buildWall(image, maze, screen):\n",
    "    rects = []\n",
    "    for i in range(L):\n",
    "        for j in range(L):\n",
    "            if maze[i][j] == WALL:\n",
    "                rects.append(screen.blit(image, (20 + j*Wallx, 40 + i*Wally)))\n",
    "    return rects\n",
    "\n",
    "def buildGround(image, array):\n",
    "    surface = pygame.Surface((L * Wallx, L * Wally))\n",
    "    for i in range(L):\n",
    "        for j in range(L):\n",
    "            if array[i][j] >= 0:\n",
    "                surface.blit(image[array[i][j]], (j*Wallx, i*Wally))\n",
    "    return surface\n",
    "\n",
    "def createFlag(image, maze, screen):\n",
    "    i = random.randrange(1, L-1)\n",
    "    j = random.randrange(1, L-1)\n",
    "    while maze[i][j]!=ROUTE or maze[i+1][j]!=ROUTE or maze[i][j+1]!=ROUTE or maze[i+1][j+1]!=ROUTE:\n",
    "        i = random.randrange(1, L-1)\n",
    "        j = random.randrange(1, L-1)\n",
    "        \n",
    "    return screen.blit(image, (20 + j*Wallx, 40 + i*Wally))\n",
    "\n",
    "def createKey(image, maze, screen):\n",
    "    i = random.randrange(1, L-1)\n",
    "    j = random.randrange(1, L-1)\n",
    "    while maze[i][j]!=ROUTE or maze[i+1][j]!=ROUTE or maze[i][j+1]!=ROUTE or maze[i+1][j+1]!=ROUTE:\n",
    "        i = random.randrange(1, L-1)\n",
    "        j = random.randrange(1, L-1)\n",
    "        \n",
    "    return screen.blit(image, (24 + j*Wallx, 44 + i*Wally))\n",
    "    \n",
    "    \n",
    "    \n",
    "############################################################\n",
    "#    Sprites 建構\n",
    "############################################################\n",
    "    \n",
    "class Player(pygame.sprite.Sprite):\n",
    "    def __init__(self):\n",
    "        pygame.sprite.Sprite.__init__(self)\n",
    "        self.playerImgs = [[pygame.image.load('sprites\\\\man_' + str(i) + str(j) +'.png').convert_alpha() \n",
    "                            for j in range(4)] for i in range(4)]\n",
    "        self.image = self.playerImgs[0][0]\n",
    "        self.imageIndex = 0\n",
    "        self.rect = self.image.get_rect()\n",
    "        self.rect.x = 20\n",
    "        self.rect.y = 44 + Wally\n",
    "        self.speedx = 0\n",
    "        self.speedy = 0\n",
    "        self.lastx = 20\n",
    "        self.lasty = 44 + Wally\n",
    "        self.inertiaXCount = 0\n",
    "        self.inertiaYCount = 0\n",
    "        self.frozenTime = None\n",
    "        self.hitTimes = 0\n",
    "        self.live = 20\n",
    "    \n",
    "    # 移動 & 圖像動畫\n",
    "    def update(self):\n",
    "        # 鍵盤操作\n",
    "        keystate = pygame.key.get_pressed()\n",
    "        if self.frozenTime is None:\n",
    "            if keystate[pygame.K_RIGHT] :\n",
    "                self.speedx = 3\n",
    "                self.inertiaXCount = 0\n",
    "            if keystate[pygame.K_DOWN] :\n",
    "                self.speedy = 3\n",
    "                self.inertiaYCount = 0\n",
    "            if keystate[pygame.K_LEFT] :\n",
    "                self.speedx = -3\n",
    "                self.inertiaXCount = 0\n",
    "            if keystate[pygame.K_UP] :\n",
    "                self.speedy = -3\n",
    "                self.inertiaYCount = 0\n",
    "        elif pygame.time.get_ticks() - self.frozenTime > 100: # 停 1 秒\n",
    "            self.frozenTime = None\n",
    "        \n",
    "        # 四向移動\n",
    "        if self.speedx > 0:\n",
    "            self.imageIndex = (self.imageIndex + 1) % 4\n",
    "            self.image = self.playerImgs[0][self.imageIndex]\n",
    "            self.rect.width = self.image.get_width()\n",
    "            if self.inertiaXCount > 0:\n",
    "                self.speedx = self.speedx ** (0.5)\n",
    "            self.inertiaXCount += 1\n",
    "            if self.inertiaXCount > 6:\n",
    "                self.speedx = 0\n",
    "                self.inertiaXCount = 0\n",
    "        elif self.speedx < 0:\n",
    "            self.imageIndex = (self.imageIndex + 1) % 4\n",
    "            self.image = self.playerImgs[2][self.imageIndex]\n",
    "            self.rect.width = self.image.get_width()\n",
    "            if self.inertiaXCount > 0:\n",
    "                self.speedx = -(abs(self.speedx) ** (0.5))\n",
    "            self.inertiaXCount += 1\n",
    "            if self.inertiaXCount > 6:\n",
    "                self.speedx = 0\n",
    "                self.inertiaXCount = 0\n",
    "        if self.speedy > 0:\n",
    "            self.imageIndex = (self.imageIndex + 1) % 4\n",
    "            self.image = self.playerImgs[1][self.imageIndex]\n",
    "            self.rect.width = self.image.get_width()\n",
    "            if self.inertiaYCount > 0:\n",
    "                self.speedy = self.speedy ** (0.5)\n",
    "            self.inertiaYCount += 1\n",
    "            if self.inertiaYCount > 6:\n",
    "                self.speedy = 0\n",
    "                self.inertiaYCount = 0\n",
    "        elif self.speedy < 0:\n",
    "            self.imageIndex = (self.imageIndex + 1) % 4\n",
    "            self.image = self.playerImgs[3][self.imageIndex]\n",
    "            self.rect.width = self.image.get_width()\n",
    "            if self.inertiaYCount > 0:\n",
    "                self.speedy = -(abs(self.speedy) ** (0.5))\n",
    "            self.inertiaYCount += 1\n",
    "            if self.inertiaYCount > 6:\n",
    "                self.speedy = 0\n",
    "                self.inertiaYCount = 0\n",
    "        self.lastx = self.rect.x\n",
    "        self.lasty = self.rect.y\n",
    "        self.rect.x = 20 if self.rect.x < 20 else (self.rect.x + self.speedx)\n",
    "        self.rect.y += self.speedy\n",
    "    \n",
    "    # 碰撞偵測\n",
    "    def colliderect(self, targetRect):\n",
    "        return self.rect.colliderect(targetRect)\n",
    "    \n",
    "    # 停止操作\n",
    "    def freeze(self):\n",
    "        self.rect.x = ((self.lastx - 20) // Wallx) * Wallx + 24\n",
    "        self.rect.y = ((self.lasty - 40) // Wally) * Wally + 44\n",
    "        self.speedx = self.speedy = 0\n",
    "        self.frozenTime = pygame.time.get_ticks()\n",
    "    def get_live(self):\n",
    "        return str(self.live)   \n",
    "        \n",
    "def finish(player, DoorRect):\n",
    "        return player.rect.x >= DoorRect.x and player.rect.y >= DoorRect.y\n",
    "\n",
    "def gameover(player):\n",
    "    #print(player.live==0)\n",
    "    return player.live <= 0\n",
    "    \n",
    "############################################################\n",
    "#    主程式\n",
    "############################################################\n",
    "\n",
    "def main():\n",
    "    # 初始化\n",
    "    pygame.mixer.pre_init(44100, -16, 1, 512)\n",
    "    pygame.init()\n",
    "    pygame.display.set_icon(pygame.image.load(\"sprites\\\\icon.png\"))\n",
    "    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n",
    "    screen.fill(WHITE)\n",
    "    pygame.display.set_caption(\"RANDOM MAZE\")\n",
    "    clock = pygame.time.Clock()\n",
    "    \n",
    "    # 載入素材\n",
    "    GroundImg = [pygame.image.load('sprites\\\\ground_' + str(i) + '.png').convert() for i in range(4)]\n",
    "    WallImg = pygame.image.load('sprites\\\\WALL.png').convert_alpha()\n",
    "    DoorImg = pygame.image.load('sprites\\\\DOOR.png').convert()\n",
    "    FlagImg = pygame.image.load('sprites\\\\flag.png').convert()\n",
    "    FlagImg.set_colorkey(WHITE)\n",
    "    KeyImg = pygame.image.load('sprites\\\\key.png').convert_alpha()\n",
    "    TimerBorderImg = pygame.image.load('sprites\\\\time_border.png').convert_alpha()\n",
    "    FinishImg = pygame.image.load('sprites\\\\finish.png').convert_alpha()\n",
    "    GameoverImg = pygame.image.load('sprites\\\\skeleton.png').convert_alpha()\n",
    "    heartImg = pygame.image.load('sprites\\\\heart.png').convert()\n",
    "    \n",
    "    # 載入音效\n",
    "    se = []\n",
    "    se.append(Sound(\"sounds\\\\wall.ogg\"))\n",
    "    se.append(Sound(\"sounds\\\\flag.ogg\"))\n",
    "    se.append(Sound(\"sounds\\\\door_open.ogg\"))\n",
    "    music.set_volume(0)\n",
    "    endingMusicPlaying = False\n",
    "    gameoverMusicPlaying = False\n",
    "    \n",
    "    # 建立場景相關元件\n",
    "    screen.fill(WHITE)\n",
    "    Maze, DoorRect = Maze_init(screen, DoorImg)\n",
    "    GroundArray = [[random.randrange(4) if Maze[j][i] == ROUTE else -1 for i in range(L)] for j in range(L)]\n",
    "    GroundSurface = buildGround(GroundImg, GroundArray)\n",
    "    GroundEffect = pygame.Surface((L * Wallx, L * Wally))\n",
    "    GroundEffect.fill((64, 64, 64))\n",
    "    GroundEffectAlpha = 2\n",
    "    GroundEffectAlpha_increment = 2\n",
    "    WallRects = buildWall(WallImg, Maze, screen)\n",
    "    FlagRect = createFlag(FlagImg, Maze, screen)\n",
    "    BlackMask = pygame.Surface((WIDTH, HEIGHT)).convert_alpha()\n",
    "    BlackMask.fill((0, 0, 0, 255))\n",
    "    BlackMask_radius = 32\n",
    "    BlackMask_RADIUS_MAX = ((WIDTH - 20) ** 2 + (HEIGHT - 20) ** 2) ** (0.5)\n",
    "    BlackMask_RADIUS_STEP = int(BlackMask_RADIUS_MAX / FPS)\n",
    "    WhiteMask = pygame.Surface((WIDTH, HEIGHT))\n",
    "    WhiteMask.fill(WHITE)\n",
    "    EndingEffectAlpha = 0\n",
    "    TransitionMask = pygame.Surface((WIDTH, HEIGHT)).convert_alpha()\n",
    "    TransitionMaskAlpha = 0\n",
    "    flagExist = True\n",
    "    doorOpened = False\n",
    "    \n",
    "    # 定義 Sprites\n",
    "    all_sprites = pygame.sprite.Group()\n",
    "    player = Player()\n",
    "    all_sprites.add(player)\n",
    "    \n",
    "    # 計時面板\n",
    "    timerBorderRect = TimerBorderImg.get_rect()\n",
    "    timerBorderRect.top = 5\n",
    "    timerBorderRect.centerx = WIDTH // 2\n",
    "    #timerFont = pygame.font.SysFont(\"Arial\", 18, bold=True)\n",
    "    #startFont = pygame.font.SysFont(\"Arial\", 16)\n",
    "    #endingFont = pygame.font.SysFont(\"Arial\", 24)\n",
    "    #timerFont = pygame.font.Font(\"freesansbold.ttf\", 18, bold=True)\n",
    "    #startFont = pygame.font.Font(\"freesansbold.ttf\", 12)\n",
    "    #endingFont = pygame.font.Font(\"freesansbold.ttf\", 24)\n",
    "    timerFont = pygame.font.Font(\"fonts\\\\Carlito-Bold.ttf\", 18)\n",
    "    startFont = pygame.font.Font(\"fonts\\\\Carlito-Regular.ttf\", 14)\n",
    "    endingFont = pygame.font.Font(\"fonts\\\\Carlito-Regular.ttf\", 24)\n",
    "    liveFont = pygame.font.Font(\"fonts\\\\Carlito-Bold.ttf\", 18)\n",
    "    gameoverFont = pygame.font.Font(\"fonts\\\\Carlito-Bold.ttf\", 48)\n",
    "    \n",
    "    time_M = time_S = 0\n",
    "    startTime = 0\n",
    "    opening = True\n",
    "    gameStart = False\n",
    "    \n",
    "    running = True\n",
    "    normalMode = True\n",
    "    hardMode = False\n",
    "    # 測試用：直接進入困難模式 \n",
    "    #normalMode = False\n",
    "    #hardMode = True\n",
    "    # Normal Mode\n",
    "    while running and normalMode:\n",
    "        clock.tick(FPS)\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                running = False\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if event.key == pygame.K_ESCAPE:\n",
    "                    running = False\n",
    "                elif opening:\n",
    "                    opening = False\n",
    "                elif finish(player, DoorRect) and event.key == pygame.K_SPACE:\n",
    "                    hardMode = True\n",
    "                    music.fadeout(750)\n",
    "        \n",
    "        # 重繪場景\n",
    "        if not (finish(player, DoorRect) or gameover(player)):\n",
    "            # 繪製背景\n",
    "            if gameStart and not player.frozenTime is None:\n",
    "                screen.fill(DARKRED)\n",
    "            else:\n",
    "                screen.fill(BLACK)\n",
    "            screen.blit(GroundSurface, (20, 40))\n",
    "            GroundEffect.set_alpha(GroundEffectAlpha)\n",
    "            GroundEffectAlpha += GroundEffectAlpha_increment\n",
    "            screen.blit(GroundEffect, (20, 40))\n",
    "            if GroundEffectAlpha > 96 or GroundEffectAlpha <= 0:\n",
    "                GroundEffectAlpha_increment = -GroundEffectAlpha_increment\n",
    "            # 繪製牆壁\n",
    "            for r in WallRects:\n",
    "                screen.blit(WallImg, r)\n",
    "                # 牆壁碰撞偵測\n",
    "                if player.colliderect(r):\n",
    "                    se[0].play()\n",
    "                    player.live -= 1\n",
    "                    player.freeze()\n",
    "            # 繪製旗子\n",
    "            if flagExist:\n",
    "                screen.blit(FlagImg, FlagRect)\n",
    "                screen.blit(DoorImg, DoorRect)\n",
    "                # 旗子碰撞偵測\n",
    "                flagExist = not player.colliderect(FlagRect)\n",
    "                # 出口上鎖碰撞偵測\n",
    "                if player.colliderect(DoorRect):\n",
    "                    se[0].play()\n",
    "                    player.freeze()\n",
    "            elif not doorOpened:\n",
    "                screen.blit(DoorImg, DoorRect)\n",
    "                se[1].play()\n",
    "                se[2].play()\n",
    "                doorOpened = True\n",
    "\n",
    "            # 遊戲開場特效\n",
    "            if opening:\n",
    "                if pygame.display.get_active():\n",
    "                    if not music.get_busy():\n",
    "                        music.load(\"sounds\\\\title.mp3\")\n",
    "                        music.play(-1)\n",
    "                    elif music.get_volume() < 1:\n",
    "                        music.set_volume(music.get_volume() + 0.05)\n",
    "                if music.get_volume() > 0.8:\n",
    "                    pygame.draw.circle(BlackMask, (0, 0, 0, 0), (FlagRect.x + 8, FlagRect.y + 8), \n",
    "                                       int(BlackMask_radius * music.get_volume()))\n",
    "                screen.blit(BlackMask, (0, 0))\n",
    "                player.freeze()\n",
    "            else:\n",
    "                if not gameStart:\n",
    "                    if BlackMask_radius < BlackMask_RADIUS_MAX:\n",
    "                        music.fadeout(750)\n",
    "                        pygame.draw.circle(BlackMask, (0, 0, 0, 0), (FlagRect.x + 8, FlagRect.y + 8), BlackMask_radius)\n",
    "                        screen.blit(BlackMask, (0, 0))\n",
    "                        BlackMask_radius += BlackMask_RADIUS_STEP\n",
    "                    else:\n",
    "                        music.load(\"sounds\\\\bgm_0\" + random.choice(\"12\") + \".mp3\")\n",
    "                        music.play(-1)\n",
    "                        gameStart = True\n",
    "                        startTime = pygame.time.get_ticks()\n",
    "\n",
    "            # 繪製計分欄位 / 開始提示\n",
    "            screen.blit(TimerBorderImg, timerBorderRect)\n",
    "            if opening:\n",
    "                timerText = startFont.render(\"Press any key to START\", True, BLACK)\n",
    "                timerTextRect = timerText.get_rect()\n",
    "                timerTextRect.top = 18\n",
    "                timerTextRect.centerx = WIDTH // 2\n",
    "            elif gameStart:\n",
    "                time_M = (pygame.time.get_ticks() - startTime) // 60000\n",
    "                time_S = ((pygame.time.get_ticks() - startTime) % 60000) // 1000\n",
    "                timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                timerTextRect = timerText.get_rect()\n",
    "                timerTextRect.top = 17\n",
    "                timerTextRect.centerx = WIDTH // 2\n",
    "                liveText = liveFont.render(player.get_live(), True, WHITE)\n",
    "                liveTextRect = liveText.get_rect()\n",
    "                liveTextRect.top = 17\n",
    "                liveTextRect.left = 45\n",
    "                screen.blit(liveText, liveTextRect)\n",
    "                screen.blit(heartImg, (15, 10))\n",
    "            screen.blit(timerText, timerTextRect)\n",
    "\n",
    "            # 繪製 Sprites\n",
    "            all_sprites.update()\n",
    "            all_sprites.draw(screen)\n",
    "        elif finish(player, DoorRect):\n",
    "            if not endingMusicPlaying:\n",
    "                music.fadeout(750)\n",
    "                music.load(\"sounds\\\\ending.mp3\")\n",
    "                music.play(-1)\n",
    "                endingMusicPlaying = True\n",
    "            if EndingEffectAlpha < 128:\n",
    "                if EndingEffectAlpha < 32:\n",
    "                    WhiteMask.set_alpha(EndingEffectAlpha)\n",
    "                    screen.blit(WhiteMask, (0, 0))\n",
    "                    screen.blit(TimerBorderImg, timerBorderRect)\n",
    "                    timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                    timerTextRect = timerText.get_rect()\n",
    "                    timerTextRect.top = 17\n",
    "                    timerTextRect.centerx = WIDTH // 2\n",
    "                    screen.blit(timerText, timerTextRect)\n",
    "                FinishImg.set_alpha(EndingEffectAlpha)\n",
    "                screen.blit(FinishImg, (WIDTH // 2 - 225, HEIGHT // 2 - 200))\n",
    "                EndingEffectAlpha += 2\n",
    "            else:\n",
    "                endingText = endingFont.render(\"Is this the end...?\", True, BLACK)\n",
    "                endingTextRect = endingText.get_rect()\n",
    "                endingTextRect.centerx = WIDTH // 2\n",
    "                endingTextRect.centery = HEIGHT - (HEIGHT // 9)\n",
    "                screen.blit(endingText, endingTextRect)\n",
    "        elif gameover(player) :\n",
    "            if not gameoverMusicPlaying:\n",
    "                music.fadeout(750)\n",
    "                music.load(\"sounds\\\\gameover.mp3\")\n",
    "                music.play(-1)\n",
    "                gameoverMusicPlaying = True\n",
    "\n",
    "            if EndingEffectAlpha < 256:\n",
    "                if EndingEffectAlpha < 32:\n",
    "                    WhiteMask.set_alpha(EndingEffectAlpha)\n",
    "                    screen.blit(WhiteMask, (0, 0))\n",
    "                    screen.blit(TimerBorderImg, timerBorderRect)\n",
    "                    timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                    timerTextRect = timerText.get_rect()\n",
    "                    timerTextRect.top = 17\n",
    "                    timerTextRect.centerx = WIDTH // 2\n",
    "                    screen.blit(timerText, timerTextRect)\n",
    "                FinishImg.set_alpha(EndingEffectAlpha)\n",
    "                screen.blit(GameoverImg, (WIDTH // 2 -200, HEIGHT // 2 - 200))\n",
    "                EndingEffectAlpha += 4\n",
    "            else:\n",
    "                gameoverText = gameoverFont.render(\"Game Over!\", True, BLACK)\n",
    "                gameoverTextRect = gameoverText.get_rect()\n",
    "                gameoverTextRect.centerx = WIDTH // 2\n",
    "                gameoverTextRect.centery = HEIGHT - (HEIGHT // 9)\n",
    "                screen.blit(gameoverText, gameoverTextRect)\n",
    "\n",
    "        \n",
    "        # 前往困難模式轉場\n",
    "        if hardMode:\n",
    "            if TransitionMaskAlpha < 256:\n",
    "                TransitionMask.fill((0, 0, 0, TransitionMaskAlpha))\n",
    "                screen.blit(TransitionMask, (0, 0))\n",
    "                TransitionMaskAlpha += 4\n",
    "            else:\n",
    "                normalMode = False\n",
    "        pygame.display.update()\n",
    "        \n",
    "    \n",
    "    # Hard Mode\n",
    "    # 重新初始化\n",
    "    # 圖像增加濾鏡\n",
    "    for img in GroundImg:\n",
    "        img.fill(DARKRED, special_flags=pygame.BLEND_MULT)\n",
    "    WallImg.fill(DARKRED, special_flags=pygame.BLEND_MULT)\n",
    "    DoorImg.fill(DARKRED, special_flags=pygame.BLEND_MULT)\n",
    "    \n",
    "    TransitionMaskAlpha = 255\n",
    "    BlackMask.fill((0, 0, 0, 255))\n",
    "    BlackMask_radius = 0\n",
    "    BlackMask_RADIUS_MAX = 64\n",
    "    EndingEffectAlpha = 0\n",
    "    \n",
    "    # 音效\n",
    "    endingMusicPlaying = False\n",
    "    \n",
    "    # 建立場景相關元件\n",
    "    Maze, DoorRect = Maze_init(screen, DoorImg, True)\n",
    "    GroundArray = [[random.randrange(4) if Maze[j][i] == ROUTE else -1 for i in range(L)] for j in range(L)]\n",
    "    GroundSurface = buildGround(GroundImg, GroundArray)\n",
    "    WallRects = buildWall(WallImg, Maze, screen)\n",
    "    KeyRect = createKey(KeyImg, Maze, screen)\n",
    "    flagExist = True\n",
    "    doorOpened = False\n",
    "    \n",
    "    # 定義 Sprites\n",
    "    all_sprites.empty()\n",
    "    player = Player()\n",
    "    all_sprites.add(player)\n",
    "    \n",
    "    # 計時面板\n",
    "    time_M = time_S = 0\n",
    "    startTime = 0\n",
    "    opening = True\n",
    "    gameStart = False\n",
    "    \n",
    "    endingString = \"For real.\"\n",
    "    textIndex = 1\n",
    "    \n",
    "    hardMode = True\n",
    "    while running and hardMode:\n",
    "        clock.tick(FPS)\n",
    "        for event in pygame.event.get():\n",
    "            if event.type == pygame.QUIT:\n",
    "                running = False\n",
    "            if event.type == pygame.KEYDOWN:\n",
    "                if event.key == pygame.K_ESCAPE:\n",
    "                    running = False\n",
    "                elif opening:\n",
    "                    opening = False\n",
    "                elif finish(player, DoorRect):\n",
    "                    hardMode = False\n",
    "                    \n",
    "        # 重繪場景\n",
    "        if not (finish(player, DoorRect) or gameover(player)):\n",
    "            # 繪製背景\n",
    "            screen.fill(BLACK)\n",
    "            screen.blit(GroundSurface, (20, 40))\n",
    "            GroundEffect.set_alpha(GroundEffectAlpha)\n",
    "            GroundEffectAlpha += GroundEffectAlpha_increment\n",
    "            screen.blit(GroundEffect, (20, 40))\n",
    "            if GroundEffectAlpha > 96 or GroundEffectAlpha <= 0:\n",
    "                GroundEffectAlpha_increment = -GroundEffectAlpha_increment\n",
    "            # 繪製牆壁\n",
    "            for r in WallRects:\n",
    "                screen.blit(WallImg, r)\n",
    "                # 牆壁碰撞偵測\n",
    "                if player.colliderect(r):\n",
    "                    se[0].play()\n",
    "                    player.live -= 1\n",
    "                    player.freeze()\n",
    "            # 繪製旗子\n",
    "            if flagExist:\n",
    "                screen.blit(KeyImg, KeyRect)\n",
    "                screen.blit(DoorImg, DoorRect)\n",
    "                # 旗子碰撞偵測\n",
    "                flagExist = not player.colliderect(KeyRect)\n",
    "                # 出口上鎖碰撞偵測\n",
    "                if player.colliderect(DoorRect):\n",
    "                    se[0].play()\n",
    "                    player.freeze()\n",
    "            elif not doorOpened:\n",
    "                screen.blit(DoorImg, DoorRect)\n",
    "                se[1].play()\n",
    "                se[2].play()\n",
    "                doorOpened = True\n",
    "            # 玩家角色聚光燈\n",
    "            if gameStart:\n",
    "                BlackMask.fill((0, 0, 0, 255))\n",
    "                pygame.draw.circle(BlackMask, (0, 0, 0, 0), (player.rect.centerx, player.rect.centery), \n",
    "                                   BlackMask_RADIUS_MAX)\n",
    "                if flagExist:\n",
    "                    pygame.draw.circle(BlackMask, (0, 0, 0, 0), (KeyRect.centerx, KeyRect.centery), 32)\n",
    "                screen.blit(BlackMask, (0, 0))\n",
    "\n",
    "            # 遊戲開場特效\n",
    "            if opening:\n",
    "                pygame.draw.circle(BlackMask, (0, 0, 0, 0), (KeyRect.centerx, KeyRect.centery), 32)\n",
    "                screen.blit(BlackMask, (0, 0))\n",
    "                player.freeze()\n",
    "            else:\n",
    "                if not gameStart:\n",
    "                    if BlackMask_radius < BlackMask_RADIUS_MAX:\n",
    "                        pygame.draw.circle(BlackMask, (0, 0, 0, 0), (player.rect.centerx, player.rect.centery), \n",
    "                                           BlackMask_radius)\n",
    "                        screen.blit(BlackMask, (0, 0))\n",
    "                        BlackMask_radius += 4\n",
    "                    else:\n",
    "                        if not music.get_busy():\n",
    "                            music.load(\"sounds\\\\bgm_hard.mp3\")\n",
    "                            music.play(-1)\n",
    "                        elif music.get_volume() < 1:\n",
    "                            music.set_volume(music.get_volume() + 0.05)\n",
    "                        gameStart = True\n",
    "                        startTime = pygame.time.get_ticks()\n",
    "\n",
    "            # 繪製計分欄位 / 開始提示\n",
    "            screen.blit(TimerBorderImg, timerBorderRect)\n",
    "            if opening:\n",
    "                timerText = startFont.render(\"Press any key to START\", True, BLACK)\n",
    "                timerTextRect = timerText.get_rect()\n",
    "                timerTextRect.top = 18\n",
    "                timerTextRect.centerx = WIDTH // 2\n",
    "            elif gameStart:\n",
    "                time_M = (pygame.time.get_ticks() - startTime) // 60000\n",
    "                time_S = ((pygame.time.get_ticks() - startTime) % 60000) // 1000\n",
    "                timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                timerTextRect = timerText.get_rect()\n",
    "                timerTextRect.top = 17\n",
    "                timerTextRect.centerx = WIDTH // 2\n",
    "                liveText = liveFont.render(player.get_live(), True, WHITE)\n",
    "                liveTextRect = liveText.get_rect()\n",
    "                liveTextRect.top = 17\n",
    "                liveTextRect.left = 45\n",
    "                screen.blit(liveText, liveTextRect)\n",
    "                screen.blit(heartImg, (15, 10))\n",
    "            screen.blit(timerText, timerTextRect)\n",
    "\n",
    "            # 繪製 Sprites\n",
    "            all_sprites.update()\n",
    "            all_sprites.draw(screen)\n",
    "\n",
    "            if TransitionMaskAlpha > 0:\n",
    "                TransitionMask.fill((0, 0, 0, TransitionMaskAlpha))\n",
    "                screen.blit(TransitionMask, (0, 0))\n",
    "                TransitionMaskAlpha -= 4\n",
    "        elif finish(player, DoorRect):\n",
    "            if not endingMusicPlaying:\n",
    "                music.fadeout(750)\n",
    "                music.load(\"sounds\\\\ending.mp3\")\n",
    "                music.play(-1)\n",
    "                endingMusicPlaying = True\n",
    "            if EndingEffectAlpha < 256:\n",
    "                WhiteMask.set_alpha(EndingEffectAlpha)\n",
    "                screen.blit(WhiteMask, (0, 0))\n",
    "                screen.blit(TimerBorderImg, timerBorderRect)\n",
    "                timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                timerTextRect = timerText.get_rect()\n",
    "                timerTextRect.top = 17\n",
    "                timerTextRect.centerx = WIDTH // 2\n",
    "                screen.blit(timerText, timerTextRect)\n",
    "                FinishImg.set_alpha(EndingEffectAlpha)\n",
    "                screen.blit(FinishImg, (WIDTH // 2 - 225, HEIGHT // 2 - 200))\n",
    "                EndingEffectAlpha += 2\n",
    "            else:\n",
    "                if textIndex//3 <= len(endingString):\n",
    "                    screen.blit(WhiteMask, (0, 0))\n",
    "                    screen.blit(TimerBorderImg, timerBorderRect)\n",
    "                    timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                    timerTextRect = timerText.get_rect()\n",
    "                    timerTextRect.top = 17\n",
    "                    timerTextRect.centerx = WIDTH // 2\n",
    "                    screen.blit(timerText, timerTextRect)\n",
    "                    screen.blit(FinishImg, (WIDTH // 2 - 225, HEIGHT // 2 - 200))\n",
    "                    endingText = endingFont.render(\"(\" + endingString[0:textIndex//3] + \")\", True, BLACK)\n",
    "                    endingTextRect = endingText.get_rect()\n",
    "                    endingTextRect.centerx = WIDTH // 2\n",
    "                    endingTextRect.centery = HEIGHT - (HEIGHT // 9)\n",
    "                    screen.blit(endingText, endingTextRect)\n",
    "                    textIndex += 1\n",
    "        elif gameover(player) :\n",
    "            if not gameoverMusicPlaying:\n",
    "                music.fadeout(750)\n",
    "                music.load(\"sounds\\\\gameover.mp3\")\n",
    "                music.play(-1)\n",
    "                gameoverMusicPlaying = True\n",
    "            if EndingEffectAlpha < 256:\n",
    "                if EndingEffectAlpha < 32:\n",
    "                    WhiteMask.set_alpha(EndingEffectAlpha)\n",
    "                    screen.blit(WhiteMask, (0, 0))\n",
    "                    screen.blit(TimerBorderImg, timerBorderRect)\n",
    "                    timerText = timerFont.render(\"TIME:   {0}:{1:0>2d}\".format(time_M, time_S), True, BLACK)\n",
    "                    timerTextRect = timerText.get_rect()\n",
    "                    timerTextRect.top = 17\n",
    "                    timerTextRect.centerx = WIDTH // 2\n",
    "                    screen.blit(timerText, timerTextRect)\n",
    "                FinishImg.set_alpha(EndingEffectAlpha)\n",
    "                screen.blit(GameoverImg, (WIDTH // 2 -200, HEIGHT // 2 - 200))\n",
    "                EndingEffectAlpha += 2\n",
    "            else:\n",
    "                gameoverText = gameoverFont.render(\"Game Over!\", True, BLACK)\n",
    "                gameoverTextRect = gameoverText.get_rect()\n",
    "                gameoverTextRect.centerx = WIDTH // 2\n",
    "                gameoverTextRect.centery = HEIGHT - (HEIGHT // 9)\n",
    "                screen.blit(gameoverText, gameoverTextRect)\n",
    "\n",
    "        pygame.display.update()\n",
    "        \n",
    "############################################################\n",
    "#    執行\n",
    "############################################################\n",
    "\n",
    "main()\n",
    "pygame.quit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "2.7.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
